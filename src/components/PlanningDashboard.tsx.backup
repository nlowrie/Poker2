import React, { useState, useEffect, useRef } from 'react';
import { BacklogItem, User } from '../types';
import { Plus, FileText, AlertCircle, CheckCircle, Upload, Trash2, Edit3, Save, X, Calendar, Users, Play, Share, StopCircle } from 'lucide-react';
import { generateSampleBacklog } from '../utils/planningPoker';
import { getActivePlanningSessions, startPlanningSession, deletePlanningSession, addItemToSession, getSessionItems, createBacklogItem, getAllBacklogItems, updateBacklogItem, deleteBacklogItem, getAssignedItems, removeItemFromSession, endPlanningSession } from '../utils/planningSession';
import VotingSession from './VotingSession';
import SessionInvite from './SessionInvite';
import UserIcon from './UserIcon';
import { supabase } from '../supabaseClient';

interface PlanningDashboardProps {
  backlogItems: BacklogItem[];
  onBacklogUpdate: (items: BacklogItem[]) => void;
  currentUser: User;
}

export default function PlanningDashboard({ backlogItems, onBacklogUpdate, currentUser }: PlanningDashboardProps) {
  const [showAddForm, setShowAddForm] = useState(false);
  const [editingItem, setEditingItem] = useState<string | null>(null);
  const [sessions, setSessions] = useState<any[]>([]);
  const [sessionName, setSessionName] = useState('');
  const [activeSession, setActiveSession] = useState<any | null>(null);
  const [draggedItem, setDraggedItem] = useState<BacklogItem | null>(null);
  const [previewSession, setPreviewSession] = useState<any | null>(null);
  const [sessionItems, setSessionItems] = useState<BacklogItem[]>([]);
  const [assignedItemIds, setAssignedItemIds] = useState<string[]>([]);
  const [sessionsWithItems, setSessionsWithItems] = useState<{[key: string]: BacklogItem[]}>({});
  const [inviteSession, setInviteSession] = useState<any | null>(null);  const [showDevPanel, setShowDevPanel] = useState(false);
  const [endingSession, setEndingSession] = useState<string | null>(null);
  
  // Notification system state
  const [notification, setNotification] = useState<{
    type: 'success' | 'error' | 'info';
    message: string;
    show: boolean;
  }>({ type: 'info', message: '', show: false });
  
  // Confirmation dialog state
  const [confirmDialog, setConfirmDialog] = useState<{
    show: boolean;
    title: string;
    message: string;
    onConfirm: () => void;
    onCancel: () => void;
  }>({
    show: false,
    title: '',
    message: '',
    onConfirm: () => {},
    onCancel: () => {}
  });
  
  // Ref to track current sessions for real-time callbacks
  const sessionsRef = useRef<any[]>([]);
  
  const [newItem, setNewItem] = useState<{
    title: string;
    description: string;
    priority: 'Low' | 'Medium' | 'High' | 'Critical';
    acceptanceCriteria: string;
  }>({
    title: '',
    description: '',
    priority: 'Medium',
    acceptanceCriteria: ''
  });
  useEffect(() => {
    loadSessions();
    loadBacklogItems();
    loadAssignedItems();
  }, []);

  // Real-time subscriptions for dashboard updates
  useEffect(() => {
    console.log('üîÑ Setting up dashboard real-time subscriptions');

    // Create channel for dashboard updates
    const dashboardChannel = supabase.channel('dashboard-updates')
      // Listen for backlog item changes (story points updates)
      .on('postgres_changes', 
        { 
          event: 'UPDATE', 
          schema: 'public', 
          table: 'backlog_items' 
        }, 
        (payload) => {
          console.log('üìù Backlog item updated:', payload);
          // Reload backlog items to get the latest data
          loadBacklogItems();
        }
      )      // Listen for new planning sessions
      .on('postgres_changes', 
        { 
          event: 'INSERT', 
          schema: 'public', 
          table: 'planning_sessions' 
        }, 
        async (payload) => {
          console.log('üÜï New planning session created:', payload);
          console.log('üîÑ Current sessions before reload:', sessionsRef.current.length);
          
          // Add a delay to ensure the database transaction is committed
          setTimeout(async () => {
            try {
              await loadSessions();
              console.log('‚úÖ Sessions reloaded after new session creation');
            } catch (error) {
              console.error('‚ùå Error reloading sessions:', error);
            }
          }, 500);
        }
      )// Listen for planning session updates (like status changes)
      .on('postgres_changes', 
        { 
          event: 'UPDATE', 
          schema: 'public', 
          table: 'planning_sessions' 
        }, 
        (payload) => {
          console.log('üìã Planning session updated:', payload);
          loadSessions();
        }
      )
      // Listen for planning session deletions
      .on('postgres_changes', 
        { 
          event: 'DELETE', 
          schema: 'public', 
          table: 'planning_sessions' 
        }, 
        (payload) => {
          console.log('üóëÔ∏è Planning session deleted:', payload);
          loadSessions();
        }
      )      // Listen for session item assignments/removals
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table: 'session_items' 
        }, 
        (payload) => {
          console.log('üîó Session items changed:', payload);
          console.log('üîó Event type:', payload.eventType);
          console.log('üîó New record:', payload.new);
          console.log('üîó Old record:', payload.old);
          
          if (payload.eventType === 'INSERT') {
            console.log('‚ûï Item was added to a session');
          } else if (payload.eventType === 'DELETE') {
            console.log('‚ûñ Item was removed from a session (back to backlog)');
          } else if (payload.eventType === 'UPDATE') {
            console.log('üîÑ Session item was updated');
          }
          
          // Reload assigned items and session data
          console.log('üîÑ Reloading assigned items due to session_items change...');
          loadAssignedItems();
          
          // Also reload backlog items to ensure filtering works correctly
          console.log('üîÑ Reloading backlog items due to session_items change...');
          loadBacklogItems();
          
          // Use ref to avoid stale closure
          if (sessionsRef.current.length > 0) {
            console.log('üîÑ Reloading sessions with items...');
            loadSessionsWithItems();
          }
          
          // Show a notification to participants about the change
          if (payload.eventType === 'INSERT') {
            console.log('üì¢ Item moved to session - should disappear from backlog');
          } else if (payload.eventType === 'DELETE') {
            console.log('üì¢ Item returned to backlog - should reappear in backlog');
          }
        }
      ).subscribe((status) => {
        console.log('üì° Dashboard subscription status:', status);
        if (status === 'SUBSCRIBED') {
          console.log('‚úÖ Successfully subscribed to dashboard real-time updates');
        } else if (status === 'CHANNEL_ERROR') {
          console.error('‚ùå Dashboard subscription error');
        } else if (status === 'TIMED_OUT') {
          console.error('‚è∞ Dashboard subscription timed out');
        } else if (status === 'CLOSED') {
          console.log('üîí Dashboard subscription closed');
        }
      });// Cleanup subscription on unmount
    return () => {
      console.log('üßπ Cleaning up dashboard subscriptions');
      dashboardChannel.unsubscribe();
    };
  }, []); // No dependencies needed since we use refs
  // Also refresh data when user returns to dashboard (e.g., from voting session)
  // And add periodic polling as fallback for real-time updates
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (!document.hidden) {
        console.log('üëÅÔ∏è Dashboard became visible - refreshing data');
        loadBacklogItems();
        loadSessions();
        loadAssignedItems();
      }
    };    // Add frequent polling every 1 second to ensure data stays synchronized
    const pollInterval = setInterval(() => {
      console.log('üîÑ Auto-refresh (1s) - updating all data');
      loadSessions();
      loadBacklogItems();
      loadAssignedItems(); // This is crucial for session item assignments
    }, 1000); // 1 second for immediate synchronization

    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      clearInterval(pollInterval);
    };  }, []);

  // Helper functions for notifications and confirmations
  const showNotification = (type: 'success' | 'error' | 'info', message: string) => {
    setNotification({ type, message, show: true });
    // Auto-hide notification after 5 seconds
    setTimeout(() => {
      setNotification(prev => ({ ...prev, show: false }));
    }, 5000);
  };

  const showConfirmDialog = (title: string, message: string, onConfirm: () => void) => {
    setConfirmDialog({
      show: true,
      title,
      message,
      onConfirm: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
        onConfirm();
      },
      onCancel: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
      }
    });
  };

  const loadSessions = async () => {
    try {
      const activeSessions = await getActivePlanningSessions();
      setSessions(activeSessions);
      sessionsRef.current = activeSessions;
    } catch (error) {
      console.error('Error loading sessions:', error);
    }
  };

  const loadBacklogItems = async () => {
    try {
      const items = await getAllBacklogItems();
      // Convert database format to component format
      const formattedItems = items.map((item: any) => ({
        id: item.id,
        title: item.title,
        description: item.description,
        priority: item.priority,
        status: item.status,
        storyPoints: item.story_points,
        estimationType: item.estimation_type,
        acceptanceCriteria: item.acceptance_criteria || []
      }));
      onBacklogUpdate(formattedItems);
    } catch (error) {
      console.error('Error loading backlog items:', error);
    }
  };
  const loadAssignedItems = async () => {
    try {
      console.log('üìã Loading assigned items...');
      const assignedIds = await getAssignedItems();
      console.log('üìã Assigned item IDs received:', assignedIds);
      setAssignedItemIds(assignedIds);
      console.log('üìã Assigned item IDs state updated');
    } catch (error) {
      console.error('Error loading assigned items:', error);
    }
  };

  const loadSessionsWithItems = async () => {
    try {
      const sessionsData: {[key: string]: BacklogItem[]} = {};
      for (const session of sessions) {
        const items = await getSessionItems(session.id);
        const sessionBacklogItems = items
          .filter((item: any) => item.backlog_items)
          .map((item: any) => ({
            id: item.backlog_items.id,
            title: item.backlog_items.title,
            description: item.backlog_items.description,
            priority: item.backlog_items.priority,
            status: item.backlog_items.status,
            storyPoints: item.backlog_items.story_points,
            estimationType: item.backlog_items.estimation_type,
            acceptanceCriteria: item.backlog_items.acceptance_criteria || []
          }));
        sessionsData[session.id] = sessionBacklogItems;
      }
      setSessionsWithItems(sessionsData);
    } catch (error) {
      console.error('Error loading sessions with items:', error);
    }
  };

  useEffect(() => {
    if (sessions.length > 0) {
      loadSessionsWithItems();
    }
  }, [sessions, assignedItemIds]);

  const handleAddItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const dbItem = await createBacklogItem({
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const formattedItem = {
        id: dbItem.id,
        title: dbItem.title,
        description: dbItem.description,
        priority: dbItem.priority,
        status: dbItem.status,
        acceptanceCriteria: dbItem.acceptance_criteria || []
      };
      
      onBacklogUpdate([...backlogItems, formattedItem]);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
      setShowAddForm(false);
    } catch (error) {
      console.error('Error adding item:', error);
    }
  };

  const handleEditItem = (item: BacklogItem) => {
    setEditingItem(item.id);
    setNewItem({
      title: item.title,
      description: item.description,
      priority: item.priority,
      acceptanceCriteria: item.acceptanceCriteria?.join('\n') || ''
    });
  };

  const handleUpdateItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateBacklogItem(editingItem!, {
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptance_criteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const updatedItems = backlogItems.map(item => 
        item.id === editingItem 
          ? {
              ...item,
              title: newItem.title,
              description: newItem.description,
              priority: newItem.priority,
              acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
            }
          : item
      );
      onBacklogUpdate(updatedItems);
      setEditingItem(null);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
    } catch (error) {
      console.error('Error updating item:', error);
    }
  };

  const handleDeleteItem = async (id: string) => {
    try {
      await deleteBacklogItem(id);
      onBacklogUpdate(backlogItems.filter(item => item.id !== id));
    } catch (error) {
      console.error('Error deleting item:', error);
    }
  };  const handleCreateSession = async () => {
    if (!sessionName.trim()) return;
    try {
      console.log('üöÄ Creating new session:', sessionName);
      const session = await startPlanningSession(sessionName, currentUser.id);
      console.log('‚úÖ Session created successfully:', session);
      
      // Immediately update local state for the user who created the session
      const updatedSessions = [...sessions, session];
      setSessions(updatedSessions);
      sessionsRef.current = updatedSessions;
      setSessionName('');
      
      console.log('üìä Local sessions updated, count:', updatedSessions.length);
      
      // Force a refresh of all sessions to ensure consistency
      setTimeout(async () => {
        try {
          console.log('üîÑ Force refreshing sessions after creation...');
          const refreshedSessions = await getActivePlanningSessions();
          setSessions(refreshedSessions);
          sessionsRef.current = refreshedSessions;
          console.log('‚úÖ Sessions force-refreshed, count:', refreshedSessions.length);
        } catch (error) {
          console.error('‚ùå Error force-refreshing sessions:', error);
        }
      }, 1000); // Delay to ensure database commit
      
      // The real-time subscription should also trigger for other users
    } catch (error) {
      console.error('‚ùå Error creating session:', error);
    }
  };  const handleDeleteSession = async (sessionId: string) => {
    try {
      await deletePlanningSession(sessionId);
      const updatedSessions = sessions.filter(s => s.id !== sessionId);
      setSessions(updatedSessions);
      sessionsRef.current = updatedSessions;
    } catch (error) {
      console.error('Error deleting session:', error);
    }
  };

  const handleEndSession = async (sessionId: string) => {
    if (!window.confirm('Are you sure you want to end this session? This will generate a summary and move it to completed sessions.')) {
      return;
    }

    try {
      setEndingSession(sessionId);
      console.log('üîö Ending session:', sessionId);
      
      const summary = await endPlanningSession(sessionId, currentUser.id);
      console.log('‚úÖ Session ended successfully, summary:', summary);
      
      // Show alert with basic summary info
      alert(`Session ended successfully!\n\nDuration: ${Math.round(summary.duration)} minutes\nStories: ${summary.stories.length}\nParticipants: ${summary.participants.length}`);
      
      // Refresh sessions to remove the ended session from active list
      await loadSessions();
      
    } catch (error) {
      console.error('‚ùå Failed to end session:', error);
      alert('Failed to end session. Please try again.');
    } finally {
      setEndingSession(null);
    }
  };

  const handleJoinSession = (session: any) => {
    setActiveSession(session);
  };
  const handleDragStart = (e: React.DragEvent<HTMLDivElement>, item: BacklogItem) => {
    console.log('Starting drag from backlog:', item.title);
    setDraggedItem(item);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  };  const handleDrop = async (e: React.DragEvent<HTMLDivElement>, sessionId: string) => {
    e.preventDefault();
    if (draggedItem) {
      try {
        console.log('üéØ Dropping item:', draggedItem.title, 'to session:', sessionId);
        
        // First, remove item from any existing session
        for (const [existingSessionId, items] of Object.entries(sessionsWithItems)) {
          if (items.some(item => item.id === draggedItem.id)) {
            console.log(`üóëÔ∏è Removing item ${draggedItem.title} from existing session ${existingSessionId}`);
            await removeItemFromSession(existingSessionId, draggedItem.id);
            console.log(`‚úÖ Removed item ${draggedItem.title} from session ${existingSessionId}`);
            break;
          }
        }
        
        // Then add to the new session
        console.log(`‚ûï Adding item ${draggedItem.title} to session ${sessionId}`);
        const result = await addItemToSession(sessionId, draggedItem.id);
        console.log('üì° Item added to session - this should trigger real-time INSERT event:', result);
        
        if (result.message === 'Item already in session') {
          console.log(`"${draggedItem.title}" is already in this session.`);
        } else {
          console.log(`‚úÖ Successfully moved "${draggedItem.title}" to session!`);
        }        
        setDraggedItem(null);
        // Refresh assigned items and sessions
        console.log('üîÑ Refreshing local data after item move...');
        await refreshAllData();
        console.log(`üéâ Successfully moved "${draggedItem.title}" to session!`);
      } catch (error: any) {
        console.error('‚ùå Error moving item to session:', error);
        setDraggedItem(null);
      }
    }
  };
  const handleDropToBacklog = async (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    if (draggedItem) {      try {
        console.log('üîÑ Dropping item back to backlog:', draggedItem.title);
        
        // Find which session this item belongs to and remove it
        for (const [sessionId, items] of Object.entries(sessionsWithItems)) {
          if (items.some(item => item.id === draggedItem.id)) {
            console.log(`üóëÔ∏è Removing item ${draggedItem.title} from session ${sessionId}`);
            await removeItemFromSession(sessionId, draggedItem.id);
            console.log(`‚úÖ Successfully removed item ${draggedItem.title} from session ${sessionId}`);
            console.log('üì° This should trigger a real-time DELETE event for all participants');
            break;
          }
        }
          setDraggedItem(null);
        // Refresh assigned items and sessions
        console.log('üîÑ Refreshing local data after item removal...');
        await refreshAllData();
        console.log(`üéâ Successfully returned "${draggedItem.title}" to backlog!`);
      } catch (error: any) {
        console.error('‚ùå Error removing item from session:', error);
        setDraggedItem(null);
      }
    }
  };
  const handleSessionItemDragStart = (e: React.DragEvent<HTMLDivElement>, item: BacklogItem) => {
    console.log('Starting drag from session:', item.title);
    setDraggedItem(item);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handlePreviewSession = async (session: any) => {
    try {
      const items = await getSessionItems(session.id);
      console.log('Session items from DB:', items); // Debug log
      
      const sessionBacklogItems = items
        .filter((item: any) => item.backlog_items) // Filter out null backlog_items
        .map((item: any) => ({
          id: item.backlog_items.id,
          title: item.backlog_items.title,
          description: item.backlog_items.description,
          priority: item.backlog_items.priority,
          status: item.backlog_items.status,
          storyPoints: item.backlog_items.story_points,
          estimationType: item.backlog_items.estimation_type,
          acceptanceCriteria: item.backlog_items.acceptance_criteria || []
        }));
      
      console.log('Formatted session items:', sessionBacklogItems); // Debug log
      setSessionItems(sessionBacklogItems);
      setPreviewSession(session);
    } catch (error) {
      console.error('Error loading session items:', error);
    }
  };

  const loadSampleData = async () => {
    try {
      const sampleItems = generateSampleBacklog();
      const createdItems = [];
      
      for (const item of sampleItems) {
        const dbItem = await createBacklogItem({
          title: item.title,
          description: item.description,
          priority: item.priority,
          acceptanceCriteria: item.acceptanceCriteria || []
        });
        
        createdItems.push({
          id: dbItem.id,
          title: dbItem.title,
          description: dbItem.description,
          priority: dbItem.priority,
          status: dbItem.status,
          acceptanceCriteria: dbItem.acceptance_criteria || []
        });
      }
      
      onBacklogUpdate([...backlogItems, ...createdItems]);
    } catch (error) {
      console.error('Error loading sample data:', error);
    }
  };

  if (activeSession) {
    return (
      <VotingSession
        backlogItems={backlogItems}
        currentUser={currentUser}
        onUpdateBacklog={onBacklogUpdate}
        onBackToBacklog={() => setActiveSession(null)}
        sessionId={activeSession.id}
      />
    );
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'Pending': return <AlertCircle className="w-4 h-4 text-orange-500" />;
      case 'Estimated': return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'Skipped': return <X className="w-4 h-4 text-gray-500" />;
      default: return <FileText className="w-4 h-4 text-blue-500" />;
    }
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'Critical': return 'bg-red-100 text-red-800 border-red-200';
      case 'High': return 'bg-orange-100 text-orange-800 border-orange-200';
      case 'Medium': return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'Low': return 'bg-green-100 text-green-800 border-green-200';
      default: return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  // Helper functions for notifications and confirmations
  const showNotification = (type: 'success' | 'error' | 'info', message: string) => {
    setNotification({ type, message, show: true });
    // Auto-hide notification after 5 seconds
    setTimeout(() => {
      setNotification(prev => ({ ...prev, show: false }));
    }, 5000);
  };

  const showConfirmDialog = (title: string, message: string, onConfirm: () => void) => {
    setConfirmDialog({
      show: true,
      title,
      message,
      onConfirm: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
        onConfirm();
      },
      onCancel: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
      }
    });
  };

  const loadSessions = async () => {
    try {
      const activeSessions = await getActivePlanningSessions();
      setSessions(activeSessions);
      sessionsRef.current = activeSessions;
    } catch (error) {
      console.error('Error loading sessions:', error);
    }
  };

  const loadBacklogItems = async () => {
    try {
      const items = await getAllBacklogItems();
      // Convert database format to component format
      const formattedItems = items.map((item: any) => ({
        id: item.id,
        title: item.title,
        description: item.description,
        priority: item.priority,
        status: item.status,
        storyPoints: item.story_points,
        estimationType: item.estimation_type,
        acceptanceCriteria: item.acceptance_criteria || []
      }));
      onBacklogUpdate(formattedItems);
    } catch (error) {
      console.error('Error loading backlog items:', error);
    }
  };
  const loadAssignedItems = async () => {
    try {
      console.log('üìã Loading assigned items...');
      const assignedIds = await getAssignedItems();
      console.log('üìã Assigned item IDs received:', assignedIds);
      setAssignedItemIds(assignedIds);
      console.log('üìã Assigned item IDs state updated');
    } catch (error) {
      console.error('Error loading assigned items:', error);
    }
  };

  const loadSessionsWithItems = async () => {
    try {
      const sessionsData: {[key: string]: BacklogItem[]} = {};
      for (const session of sessions) {
        const items = await getSessionItems(session.id);
        const sessionBacklogItems = items
          .filter((item: any) => item.backlog_items)
          .map((item: any) => ({
            id: item.backlog_items.id,
            title: item.backlog_items.title,
            description: item.backlog_items.description,
            priority: item.backlog_items.priority,
            status: item.backlog_items.status,
            storyPoints: item.backlog_items.story_points,
            estimationType: item.backlog_items.estimation_type,
            acceptanceCriteria: item.backlog_items.acceptance_criteria || []
          }));
        sessionsData[session.id] = sessionBacklogItems;
      }
      setSessionsWithItems(sessionsData);
    } catch (error) {
      console.error('Error loading sessions with items:', error);
    }
  };

  useEffect(() => {
    if (sessions.length > 0) {
      loadSessionsWithItems();
    }
  }, [sessions, assignedItemIds]);

  const handleAddItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const dbItem = await createBacklogItem({
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const formattedItem = {
        id: dbItem.id,
        title: dbItem.title,
        description: dbItem.description,
        priority: dbItem.priority,
        status: dbItem.status,
        acceptanceCriteria: dbItem.acceptance_criteria || []
      };
      
      onBacklogUpdate([...backlogItems, formattedItem]);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
      setShowAddForm(false);
    } catch (error) {
      console.error('Error adding item:', error);
    }
  };

  const handleEditItem = (item: BacklogItem) => {
    setEditingItem(item.id);
    setNewItem({
      title: item.title,
      description: item.description,
      priority: item.priority,
      acceptanceCriteria: item.acceptanceCriteria?.join('\n') || ''
    });
  };

  const handleUpdateItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateBacklogItem(editingItem!, {
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptance_criteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const updatedItems = backlogItems.map(item => 
        item.id === editingItem 
          ? {
              ...item,
              title: newItem.title,
              description: newItem.description,
              priority: newItem.priority,
              acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
            }
          : item
      );
      onBacklogUpdate(updatedItems);
      setEditingItem(null);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
    } catch (error) {
      console.error('Error updating item:', error);
    }
  };

  const handleDeleteItem = async (id: string) => {
    try {
      await deleteBacklogItem(id);
      onBacklogUpdate(backlogItems.filter(item => item.id !== id));
    } catch (error) {
      console.error('Error deleting item:', error);
    }
  };  const handleCreateSession = async () => {
    if (!sessionName.trim()) return;
    try {
      console.log('üöÄ Creating new session:', sessionName);
      const session = await startPlanningSession(sessionName, currentUser.id);
      console.log('‚úÖ Session created successfully:', session);
      
      // Immediately update local state for the user who created the session
      const updatedSessions = [...sessions, session];
      setSessions(updatedSessions);
      sessionsRef.current = updatedSessions;
      setSessionName('');
      
      console.log('üìä Local sessions updated, count:', updatedSessions.length);
      
      // Force a refresh of all sessions to ensure consistency
      setTimeout(async () => {
        try {
          console.log('üîÑ Force refreshing sessions after creation...');
          const refreshedSessions = await getActivePlanningSessions();
          setSessions(refreshedSessions);
          sessionsRef.current = refreshedSessions;
          console.log('‚úÖ Sessions force-refreshed, count:', refreshedSessions.length);
        } catch (error) {
          console.error('‚ùå Error force-refreshing sessions:', error);
        }
      }, 1000); // Delay to ensure database commit
      
      // The real-time subscription should also trigger for other users
    } catch (error) {
      console.error('‚ùå Error creating session:', error);
    }
  };  const handleDeleteSession = async (sessionId: string) => {
    try {
      await deletePlanningSession(sessionId);
      const updatedSessions = sessions.filter(s => s.id !== sessionId);
      setSessions(updatedSessions);
      sessionsRef.current = updatedSessions;
    } catch (error) {
      console.error('Error deleting session:', error);
    }
  };

  const handleEndSession = async (sessionId: string) => {
    if (!window.confirm('Are you sure you want to end this session? This will generate a summary and move it to completed sessions.')) {
      return;
    }

    try {
      setEndingSession(sessionId);
      console.log('üîö Ending session:', sessionId);
      
      const summary = await endPlanningSession(sessionId, currentUser.id);
      console.log('‚úÖ Session ended successfully, summary:', summary);
      
      // Show alert with basic summary info
      alert(`Session ended successfully!\n\nDuration: ${Math.round(summary.duration)} minutes\nStories: ${summary.stories.length}\nParticipants: ${summary.participants.length}`);
      
      // Refresh sessions to remove the ended session from active list
      await loadSessions();
      
    } catch (error) {
      console.error('‚ùå Failed to end session:', error);
      alert('Failed to end session. Please try again.');
    } finally {
      setEndingSession(null);
    }
  };

  const handleJoinSession = (session: any) => {
    setActiveSession(session);
  };
  const handleDragStart = (e: React.DragEvent<HTMLDivElement>, item: BacklogItem) => {
    console.log('Starting drag from backlog:', item.title);
    setDraggedItem(item);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  };  const handleDrop = async (e: React.DragEvent<HTMLDivElement>, sessionId: string) => {
    e.preventDefault();
    if (draggedItem) {
      try {
        console.log('üéØ Dropping item:', draggedItem.title, 'to session:', sessionId);
        
        // First, remove item from any existing session
        for (const [existingSessionId, items] of Object.entries(sessionsWithItems)) {
          if (items.some(item => item.id === draggedItem.id)) {
            console.log(`üóëÔ∏è Removing item ${draggedItem.title} from existing session ${existingSessionId}`);
            await removeItemFromSession(existingSessionId, draggedItem.id);
            console.log(`‚úÖ Removed item ${draggedItem.title} from session ${existingSessionId}`);
            break;
          }
        }
        
        // Then add to the new session
        console.log(`‚ûï Adding item ${draggedItem.title} to session ${sessionId}`);
        const result = await addItemToSession(sessionId, draggedItem.id);
        console.log('üì° Item added to session - this should trigger real-time INSERT event:', result);
        
        if (result.message === 'Item already in session') {
          console.log(`"${draggedItem.title}" is already in this session.`);
        } else {
          console.log(`‚úÖ Successfully moved "${draggedItem.title}" to session!`);
        }        
        setDraggedItem(null);
        // Refresh assigned items and sessions
        console.log('üîÑ Refreshing local data after item move...');
        await refreshAllData();
        console.log(`üéâ Successfully moved "${draggedItem.title}" to session!`);
      } catch (error: any) {
        console.error('‚ùå Error moving item to session:', error);
        setDraggedItem(null);
      }
    }
  };
  const handleDropToBacklog = async (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    if (draggedItem) {      try {
        console.log('üîÑ Dropping item back to backlog:', draggedItem.title);
        
        // Find which session this item belongs to and remove it
        for (const [sessionId, items] of Object.entries(sessionsWithItems)) {
          if (items.some(item => item.id === draggedItem.id)) {
            console.log(`üóëÔ∏è Removing item ${draggedItem.title} from session ${sessionId}`);
            await removeItemFromSession(sessionId, draggedItem.id);
            console.log(`‚úÖ Successfully removed item ${draggedItem.title} from session ${sessionId}`);
            console.log('üì° This should trigger a real-time DELETE event for all participants');
            break;
          }
        }
          setDraggedItem(null);
        // Refresh assigned items and sessions
        console.log('üîÑ Refreshing local data after item removal...');
        await refreshAllData();
        console.log(`üéâ Successfully returned "${draggedItem.title}" to backlog!`);
      } catch (error: any) {
        console.error('‚ùå Error removing item from session:', error);
        setDraggedItem(null);
      }
    }
  };
  const handleSessionItemDragStart = (e: React.DragEvent<HTMLDivElement>, item: BacklogItem) => {
    console.log('Starting drag from session:', item.title);
    setDraggedItem(item);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handlePreviewSession = async (session: any) => {
    try {
      const items = await getSessionItems(session.id);
      console.log('Session items from DB:', items); // Debug log
      
      const sessionBacklogItems = items
        .filter((item: any) => item.backlog_items) // Filter out null backlog_items
        .map((item: any) => ({
          id: item.backlog_items.id,
          title: item.backlog_items.title,
          description: item.backlog_items.description,
          priority: item.backlog_items.priority,
          status: item.backlog_items.status,
          storyPoints: item.backlog_items.story_points,
          estimationType: item.backlog_items.estimation_type,
          acceptanceCriteria: item.backlog_items.acceptance_criteria || []
        }));
      
      console.log('Formatted session items:', sessionBacklogItems); // Debug log
      setSessionItems(sessionBacklogItems);
      setPreviewSession(session);
    } catch (error) {
      console.error('Error loading session items:', error);
    }
  };

  const loadSampleData = async () => {
    try {
      const sampleItems = generateSampleBacklog();
      const createdItems = [];
      
      for (const item of sampleItems) {
        const dbItem = await createBacklogItem({
          title: item.title,
          description: item.description,
          priority: item.priority,
          acceptanceCriteria: item.acceptanceCriteria || []
        });
        
        createdItems.push({
          id: dbItem.id,
          title: dbItem.title,
          description: dbItem.description,
          priority: dbItem.priority,
          status: dbItem.status,
          acceptanceCriteria: dbItem.acceptance_criteria || []
        });
      }
      
      onBacklogUpdate([...backlogItems, ...createdItems]);
    } catch (error) {
      console.error('Error loading sample data:', error);
    }
  };

  if (activeSession) {
    return (
      <VotingSession
        backlogItems={backlogItems}
        currentUser={currentUser}
        onUpdateBacklog={onBacklogUpdate}
        onBackToBacklog={() => setActiveSession(null)}
        sessionId={activeSession.id}
      />
    );
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'Pending': return <AlertCircle className="w-4 h-4 text-orange-500" />;
      case 'Estimated': return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'Skipped': return <X className="w-4 h-4 text-gray-500" />;
      default: return <FileText className="w-4 h-4 text-blue-500" />;
    }
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'Critical': return 'bg-red-100 text-red-800 border-red-200';
      case 'High': return 'bg-orange-100 text-orange-800 border-orange-200';
      case 'Medium': return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'Low': return 'bg-green-100 text-green-800 border-green-200';
      default: return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  // Helper functions for notifications and confirmations
  const showNotification = (type: 'success' | 'error' | 'info', message: string) => {
    setNotification({ type, message, show: true });
    // Auto-hide notification after 5 seconds
    setTimeout(() => {
      setNotification(prev => ({ ...prev, show: false }));
    }, 5000);
  };

  const showConfirmDialog = (title: string, message: string, onConfirm: () => void) => {
    setConfirmDialog({
      show: true,
      title,
      message,
      onConfirm: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
        onConfirm();
      },
      onCancel: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
      }
    });
  };

  const loadSessions = async () => {
    try {
      const activeSessions = await getActivePlanningSessions();
      setSessions(activeSessions);
      sessionsRef.current = activeSessions;
    } catch (error) {
      console.error('Error loading sessions:', error);
    }
  };

  const loadBacklogItems = async () => {
    try {
      const items = await getAllBacklogItems();
      // Convert database format to component format
      const formattedItems = items.map((item: any) => ({
        id: item.id,
        title: item.title,
        description: item.description,
        priority: item.priority,
        status: item.status,
        storyPoints: item.story_points,
        estimationType: item.estimation_type,
        acceptanceCriteria: item.acceptance_criteria || []
      }));
      onBacklogUpdate(formattedItems);
    } catch (error) {
      console.error('Error loading backlog items:', error);
    }
  };
  const loadAssignedItems = async () => {
    try {
      console.log('üìã Loading assigned items...');
      const assignedIds = await getAssignedItems();
      console.log('üìã Assigned item IDs received:', assignedIds);
      setAssignedItemIds(assignedIds);
      console.log('üìã Assigned item IDs state updated');
    } catch (error) {
      console.error('Error loading assigned items:', error);
    }
  };

  const loadSessionsWithItems = async () => {
    try {
      const sessionsData: {[key: string]: BacklogItem[]} = {};
      for (const session of sessions) {
        const items = await getSessionItems(session.id);
        const sessionBacklogItems = items
          .filter((item: any) => item.backlog_items)
          .map((item: any) => ({
            id: item.backlog_items.id,
            title: item.backlog_items.title,
            description: item.backlog_items.description,
            priority: item.backlog_items.priority,
            status: item.backlog_items.status,
            storyPoints: item.backlog_items.story_points,
            estimationType: item.backlog_items.estimation_type,
            acceptanceCriteria: item.backlog_items.acceptance_criteria || []
          }));
        sessionsData[session.id] = sessionBacklogItems;
      }
      setSessionsWithItems(sessionsData);
    } catch (error) {
      console.error('Error loading sessions with items:', error);
    }
  };

  useEffect(() => {
    if (sessions.length > 0) {
      loadSessionsWithItems();
    }
  }, [sessions, assignedItemIds]);

  const handleAddItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const dbItem = await createBacklogItem({
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const formattedItem = {
        id: dbItem.id,
        title: dbItem.title,
        description: dbItem.description,
        priority: dbItem.priority,
        status: dbItem.status,
        acceptanceCriteria: dbItem.acceptance_criteria || []
      };
      
      onBacklogUpdate([...backlogItems, formattedItem]);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
      setShowAddForm(false);
    } catch (error) {
      console.error('Error adding item:', error);
    }
  };

  const handleEditItem = (item: BacklogItem) => {
    setEditingItem(item.id);
    setNewItem({
      title: item.title,
      description: item.description,
      priority: item.priority,
      acceptanceCriteria: item.acceptanceCriteria?.join('\n') || ''
    });
  };

  const handleUpdateItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateBacklogItem(editingItem!, {
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptance_criteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const updatedItems = backlogItems.map(item => 
        item.id === editingItem 
          ? {
              ...item,
              title: newItem.title,
              description: newItem.description,
              priority: newItem.priority,
              acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
            }
          : item
      );
      onBacklogUpdate(updatedItems);
      setEditingItem(null);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
    } catch (error) {
      console.error('Error updating item:', error);
    }
  };

  const handleDeleteItem = async (id: string) => {
    try {
      await deleteBacklogItem(id);
      onBacklogUpdate(backlogItems.filter(item => item.id !== id));
    } catch (error) {
      console.error('Error deleting item:', error);
    }
  };  const handleCreateSession = async () => {
    if (!sessionName.trim()) return;
    try {
      console.log('üöÄ Creating new session:', sessionName);
      const session = await startPlanningSession(sessionName, currentUser.id);
      console.log('‚úÖ Session created successfully:', session);
      
      // Immediately update local state for the user who created the session
      const updatedSessions = [...sessions, session];
      setSessions(updatedSessions);
      sessionsRef.current = updatedSessions;
      setSessionName('');
      
      console.log('üìä Local sessions updated, count:', updatedSessions.length);
      
      // Force a refresh of all sessions to ensure consistency
      setTimeout(async () => {
        try {
          console.log('üîÑ Force refreshing sessions after creation...');
          const refreshedSessions = await getActivePlanningSessions();
          setSessions(refreshedSessions);
          sessionsRef.current = refreshedSessions;
          console.log('‚úÖ Sessions force-refreshed, count:', refreshedSessions.length);
        } catch (error) {
          console.error('‚ùå Error force-refreshing sessions:', error);
        }
      }, 1000); // Delay to ensure database commit
      
      // The real-time subscription should also trigger for other users
    } catch (error) {
      console.error('‚ùå Error creating session:', error);
    }
  };  const handleDeleteSession = async (sessionId: string) => {
    try {
      await deletePlanningSession(sessionId);
      const updatedSessions = sessions.filter(s => s.id !== sessionId);
      setSessions(updatedSessions);
      sessionsRef.current = updatedSessions;
    } catch (error) {
      console.error('Error deleting session:', error);
    }
  };

  const handleEndSession = async (sessionId: string) => {
    if (!window.confirm('Are you sure you want to end this session? This will generate a summary and move it to completed sessions.')) {
      return;
    }

    try {
      setEndingSession(sessionId);
      console.log('üîö Ending session:', sessionId);
      
      const summary = await endPlanningSession(sessionId, currentUser.id);
      console.log('‚úÖ Session ended successfully, summary:', summary);
      
      // Show alert with basic summary info
      alert(`Session ended successfully!\n\nDuration: ${Math.round(summary.duration)} minutes\nStories: ${summary.stories.length}\nParticipants: ${summary.participants.length}`);
      
      // Refresh sessions to remove the ended session from active list
      await loadSessions();
      
    } catch (error) {
      console.error('‚ùå Failed to end session:', error);
      alert('Failed to end session. Please try again.');
    } finally {
      setEndingSession(null);
    }
  };

  const handleJoinSession = (session: any) => {
    setActiveSession(session);
  };
  const handleDragStart = (e: React.DragEvent<HTMLDivElement>, item: BacklogItem) => {
    console.log('Starting drag from backlog:', item.title);
    setDraggedItem(item);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  };  const handleDrop = async (e: React.DragEvent<HTMLDivElement>, sessionId: string) => {
    e.preventDefault();
    if (draggedItem) {
      try {
        console.log('üéØ Dropping item:', draggedItem.title, 'to session:', sessionId);
        
        // First, remove item from any existing session
        for (const [existingSessionId, items] of Object.entries(sessionsWithItems)) {
          if (items.some(item => item.id === draggedItem.id)) {
            console.log(`üóëÔ∏è Removing item ${draggedItem.title} from existing session ${existingSessionId}`);
            await removeItemFromSession(existingSessionId, draggedItem.id);
            console.log(`‚úÖ Removed item ${draggedItem.title} from session ${existingSessionId}`);
            break;
          }
        }
        
        // Then add to the new session
        console.log(`‚ûï Adding item ${draggedItem.title} to session ${sessionId}`);
        const result = await addItemToSession(sessionId, draggedItem.id);
        console.log('üì° Item added to session - this should trigger real-time INSERT event:', result);
        
        if (result.message === 'Item already in session') {
          console.log(`"${draggedItem.title}" is already in this session.`);
        } else {
          console.log(`‚úÖ Successfully moved "${draggedItem.title}" to session!`);
        }        
        setDraggedItem(null);
        // Refresh assigned items and sessions
        console.log('üîÑ Refreshing local data after item move...');
        await refreshAllData();
        console.log(`üéâ Successfully moved "${draggedItem.title}" to session!`);
      } catch (error: any) {
        console.error('‚ùå Error moving item to session:', error);
        setDraggedItem(null);
      }
    }
  };
  const handleDropToBacklog = async (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    if (draggedItem) {      try {
        console.log('üîÑ Dropping item back to backlog:', draggedItem.title);
        
        // Find which session this item belongs to and remove it
        for (const [sessionId, items] of Object.entries(sessionsWithItems)) {
          if (items.some(item => item.id === draggedItem.id)) {
            console.log(`üóëÔ∏è Removing item ${draggedItem.title} from session ${sessionId}`);
            await removeItemFromSession(sessionId, draggedItem.id);
            console.log(`‚úÖ Successfully removed item ${draggedItem.title} from session ${sessionId}`);
            console.log('üì° This should trigger a real-time DELETE event for all participants');
            break;
          }
        }
          setDraggedItem(null);
        // Refresh assigned items and sessions
        console.log('üîÑ Refreshing local data after item removal...');
        await refreshAllData();
        console.log(`üéâ Successfully returned "${draggedItem.title}" to backlog!`);
      } catch (error: any) {
        console.error('‚ùå Error removing item from session:', error);
        setDraggedItem(null);
      }
    }
  };
  const handleSessionItemDragStart = (e: React.DragEvent<HTMLDivElement>, item: BacklogItem) => {
    console.log('Starting drag from session:', item.title);
    setDraggedItem(item);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handlePreviewSession = async (session: any) => {
    try {
      const items = await getSessionItems(session.id);
      console.log('Session items from DB:', items); // Debug log
      
      const sessionBacklogItems = items
        .filter((item: any) => item.backlog_items) // Filter out null backlog_items
        .map((item: any) => ({
          id: item.backlog_items.id,
          title: item.backlog_items.title,
          description: item.backlog_items.description,
          priority: item.backlog_items.priority,
          status: item.backlog_items.status,
          storyPoints: item.backlog_items.story_points,
          estimationType: item.backlog_items.estimation_type,
          acceptanceCriteria: item.backlog_items.acceptance_criteria || []
        }));
      
      console.log('Formatted session items:', sessionBacklogItems); // Debug log
      setSessionItems(sessionBacklogItems);
      setPreviewSession(session);
    } catch (error) {
      console.error('Error loading session items:', error);
    }
  };

  const loadSampleData = async () => {
    try {
      const sampleItems = generateSampleBacklog();
      const createdItems = [];
      
      for (const item of sampleItems) {
        const dbItem = await createBacklogItem({
          title: item.title,
          description: item.description,
          priority: item.priority,
          acceptanceCriteria: item.acceptanceCriteria || []
        });
        
        createdItems.push({
          id: dbItem.id,
          title: dbItem.title,
          description: dbItem.description,
          priority: dbItem.priority,
          status: dbItem.status,
          acceptanceCriteria: dbItem.acceptance_criteria || []
        });
      }
      
      onBacklogUpdate([...backlogItems, ...createdItems]);
    } catch (error) {
      console.error('Error loading sample data:', error);
    }
  };

  if (activeSession) {
    return (
      <VotingSession
        backlogItems={backlogItems}
        currentUser={currentUser}
        onUpdateBacklog={onBacklogUpdate}
        onBackToBacklog={() => setActiveSession(null)}
        sessionId={activeSession.id}
      />
    );
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'Pending': return <AlertCircle className="w-4 h-4 text-orange-500" />;
      case 'Estimated': return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'Skipped': return <X className="w-4 h-4 text-gray-500" />;
      default: return <FileText className="w-4 h-4 text-blue-500" />;
    }
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'Critical': return 'bg-red-100 text-red-800 border-red-200';
      case 'High': return 'bg-orange-100 text-orange-800 border-orange-200';
      case 'Medium': return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'Low': return 'bg-green-100 text-green-800 border-green-200';
      default: return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  // Helper functions for notifications and confirmations
  const showNotification = (type: 'success' | 'error' | 'info', message: string) => {
    setNotification({ type, message, show: true });
    // Auto-hide notification after 5 seconds
    setTimeout(() => {
      setNotification(prev => ({ ...prev, show: false }));
    }, 5000);
  };

  const showConfirmDialog = (title: string, message: string, onConfirm: () => void) => {
    setConfirmDialog({
      show: true,
      title,
      message,
      onConfirm: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
        onConfirm();
      },
      onCancel: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
      }
    });
  };

  const loadSessions = async () => {
    try {
      const activeSessions = await getActivePlanningSessions();
      setSessions(activeSessions);
      sessionsRef.current = activeSessions;
    } catch (error) {
      console.error('Error loading sessions:', error);
    }
  };

  const loadBacklogItems = async () => {
    try {
      const items = await getAllBacklogItems();
      // Convert database format to component format
      const formattedItems = items.map((item: any) => ({
        id: item.id,
        title: item.title,
        description: item.description,
        priority: item.priority,
        status: item.status,
        storyPoints: item.story_points,
        estimationType: item.estimation_type,
        acceptanceCriteria: item.acceptance_criteria || []
      }));
      onBacklogUpdate(formattedItems);
    } catch (error) {
      console.error('Error loading backlog items:', error);
    }
  };
  const loadAssignedItems = async () => {
    try {
      console.log('üìã Loading assigned items...');
      const assignedIds = await getAssignedItems();
      console.log('üìã Assigned item IDs received:', assignedIds);
      setAssignedItemIds(assignedIds);
      console.log('üìã Assigned item IDs state updated');
    } catch (error) {
      console.error('Error loading assigned items:', error);
    }
  };

  const loadSessionsWithItems = async () => {
    try {
      const sessionsData: {[key: string]: BacklogItem[]} = {};
      for (const session of sessions) {
        const items = await getSessionItems(session.id);
        const sessionBacklogItems = items
          .filter((item: any) => item.backlog_items)
          .map((item: any) => ({
            id: item.backlog_items.id,
            title: item.backlog_items.title,
            description: item.backlog_items.description,
            priority: item.backlog_items.priority,
            status: item.backlog_items.status,
            storyPoints: item.backlog_items.story_points,
            estimationType: item.backlog_items.estimation_type,
            acceptanceCriteria: item.backlog_items.acceptance_criteria || []
          }));
        sessionsData[session.id] = sessionBacklogItems;
      }
      setSessionsWithItems(sessionsData);
    } catch (error) {
      console.error('Error loading sessions with items:', error);
    }
  };

  useEffect(() => {
    if (sessions.length > 0) {
      loadSessionsWithItems();
    }
  }, [sessions, assignedItemIds]);

  const handleAddItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const dbItem = await createBacklogItem({
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const formattedItem = {
        id: dbItem.id,
        title: dbItem.title,
        description: dbItem.description,
        priority: dbItem.priority,
        status: dbItem.status,
        acceptanceCriteria: dbItem.acceptance_criteria || []
      };
      
      onBacklogUpdate([...backlogItems, formattedItem]);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
      setShowAddForm(false);
    } catch (error) {
      console.error('Error adding item:', error);
    }
  };

  const handleEditItem = (item: BacklogItem) => {
    setEditingItem(item.id);
    setNewItem({
      title: item.title,
      description: item.description,
      priority: item.priority,
      acceptanceCriteria: item.acceptanceCriteria?.join('\n') || ''
    });
  };

  const handleUpdateItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateBacklogItem(editingItem!, {
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptance_criteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const updatedItems = backlogItems.map(item => 
        item.id === editingItem 
          ? {
              ...item,
              title: newItem.title,
              description: newItem.description,
              priority: newItem.priority,
              acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
            }
          : item
      );
      onBacklogUpdate(updatedItems);
      setEditingItem(null);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
    } catch (error) {
      console.error('Error updating item:', error);
    }
  };

  const handleDeleteItem = async (id: string) => {
    try {
      await deleteBacklogItem(id);
      onBacklogUpdate(backlogItems.filter(item => item.id !== id));
    } catch (error) {
      console.error('Error deleting item:', error);
    }
  };  const handleCreateSession = async () => {
    if (!sessionName.trim()) return;
    try {
      console.log('üöÄ Creating new session:', sessionName);
      const session = await startPlanningSession(sessionName, currentUser.id);
      console.log('‚úÖ Session created successfully:', session);
      
      // Immediately update local state for the user who created the session
      const updatedSessions = [...sessions, session];
      setSessions(updatedSessions);
      sessionsRef.current = updatedSessions;
      setSessionName('');
      
      console.log('üìä Local sessions updated, count:', updatedSessions.length);
      
      // Force a refresh of all sessions to ensure consistency
      setTimeout(async () => {
        try {
          console.log('üîÑ Force refreshing sessions after creation...');
          const refreshedSessions = await getActivePlanningSessions();
          setSessions(refreshedSessions);
          sessionsRef.current = refreshedSessions;
          console.log('‚úÖ Sessions force-refreshed, count:', refreshedSessions.length);
        } catch (error) {
          console.error('‚ùå Error force-refreshing sessions:', error);
        }
      }, 1000); // Delay to ensure database commit
      
      // The real-time subscription should also trigger for other users
    } catch (error) {
      console.error('‚ùå Error creating session:', error);
    }
  };  const handleDeleteSession = async (sessionId: string) => {
    try {
      await deletePlanningSession(sessionId);
      const updatedSessions = sessions.filter(s => s.id !== sessionId);
      setSessions(updatedSessions);
      sessionsRef.current = updatedSessions;
    } catch (error) {
      console.error('Error deleting session:', error);
    }
  };

  const handleEndSession = async (sessionId: string) => {
    if (!window.confirm('Are you sure you want to end this session? This will generate a summary and move it to completed sessions.')) {
      return;
    }

    try {
      setEndingSession(sessionId);
      console.log('üîö Ending session:', sessionId);
      
      const summary = await endPlanningSession(sessionId, currentUser.id);
      console.log('‚úÖ Session ended successfully, summary:', summary);
      
      // Show alert with basic summary info
      alert(`Session ended successfully!\n\nDuration: ${Math.round(summary.duration)} minutes\nStories: ${summary.stories.length}\nParticipants: ${summary.participants.length}`);
      
      // Refresh sessions to remove the ended session from active list
      await loadSessions();
      
    } catch (error) {
      console.error('‚ùå Failed to end session:', error);
      alert('Failed to end session. Please try again.');
    } finally {
      setEndingSession(null);
    }
  };

  const handleJoinSession = (session: any) => {
    setActiveSession(session);
  };
  const handleDragStart = (e: React.DragEvent<HTMLDivElement>, item: BacklogItem) => {
    console.log('Starting drag from backlog:', item.title);
    setDraggedItem(item);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  };  const handleDrop = async (e: React.DragEvent<HTMLDivElement>, sessionId: string) => {
    e.preventDefault();
    if (draggedItem) {
      try {
        console.log('üéØ Dropping item:', draggedItem.title, 'to session:', sessionId);
        
        // First, remove item from any existing session
        for (const [existingSessionId, items] of Object.entries(sessionsWithItems)) {
          if (items.some(item => item.id === draggedItem.id)) {
            console.log(`üóëÔ∏è Removing item ${draggedItem.title} from existing session ${existingSessionId}`);
            await removeItemFromSession(existingSessionId, draggedItem.id);
            console.log(`‚úÖ Removed item ${draggedItem.title} from session ${existingSessionId}`);
            break;
          }
        }
        
        // Then add to the new session
        console.log(`‚ûï Adding item ${draggedItem.title} to session ${sessionId}`);
        const result = await addItemToSession(sessionId, draggedItem.id);
        console.log('üì° Item added to session - this should trigger real-time INSERT event:', result);
        
        if (result.message === 'Item already in session') {
          console.log(`"${draggedItem.title}" is already in this session.`);
        } else {
          console.log(`‚úÖ Successfully moved "${draggedItem.title}" to session!`);
        }        
        setDraggedItem(null);
        // Refresh assigned items and sessions
        console.log('üîÑ Refreshing local data after item move...');
        await refreshAllData();
        console.log(`üéâ Successfully moved "${draggedItem.title}" to session!`);
      } catch (error: any) {
        console.error('‚ùå Error moving item to session:', error);
        setDraggedItem(null);
      }
    }
  };
  const handleDropToBacklog = async (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    if (draggedItem) {      try {
        console.log('üîÑ Dropping item back to backlog:', draggedItem.title);
        
        // Find which session this item belongs to and remove it
        for (const [sessionId, items] of Object.entries(sessionsWithItems)) {
          if (items.some(item => item.id === draggedItem.id)) {
            console.log(`üóëÔ∏è Removing item ${draggedItem.title} from session ${sessionId}`);
            await removeItemFromSession(sessionId, draggedItem.id);
            console.log(`‚úÖ Successfully removed item ${draggedItem.title} from session ${sessionId}`);
            console.log('üì° This should trigger a real-time DELETE event for all participants');
            break;
          }
        }
          setDraggedItem(null);
        // Refresh assigned items and sessions
        console.log('üîÑ Refreshing local data after item removal...');
        await refreshAllData();
        console.log(`üéâ Successfully returned "${draggedItem.title}" to backlog!`);
      } catch (error: any) {
        console.error('‚ùå Error removing item from session:', error);
        setDraggedItem(null);
      }
    }
  };
  const handleSessionItemDragStart = (e: React.DragEvent<HTMLDivElement>, item: BacklogItem) => {
    console.log('Starting drag from session:', item.title);
    setDraggedItem(item);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handlePreviewSession = async (session: any) => {
    try {
      const items = await getSessionItems(session.id);
      console.log('Session items from DB:', items); // Debug log
      
      const sessionBacklogItems = items
        .filter((item: any) => item.backlog_items) // Filter out null backlog_items
        .map((item: any) => ({
          id: item.backlog_items.id,
          title: item.backlog_items.title,
          description: item.backlog_items.description,
          priority: item.backlog_items.priority,
          status: item.backlog_items.status,
          storyPoints: item.backlog_items.story_points,
          estimationType: item.backlog_items.estimation_type,
          acceptanceCriteria: item.backlog_items.acceptance_criteria || []
        }));
      
      console.log('Formatted session items:', sessionBacklogItems); // Debug log
      setSessionItems(sessionBacklogItems);
      setPreviewSession(session);
    } catch (error) {
      console.error('Error loading session items:', error);
    }
  };

  const loadSampleData = async () => {
    try {
      const sampleItems = generateSampleBacklog();
      const createdItems = [];
      
      for (const item of sampleItems) {
        const dbItem = await createBacklogItem({
          title: item.title,
          description: item.description,
          priority: item.priority,
          acceptanceCriteria: item.acceptanceCriteria || []
        });
        
        createdItems.push({
          id: dbItem.id,
          title: dbItem.title,
          description: dbItem.description,
          priority: dbItem.priority,
          status: dbItem.status,
          acceptanceCriteria: dbItem.acceptance_criteria || []
        });
      }
      
      onBacklogUpdate([...backlogItems, ...createdItems]);
    } catch (error) {
      console.error('Error loading sample data:', error);
    }
  };

  if (activeSession) {
    return (
      <VotingSession
        backlogItems={backlogItems}
        currentUser={currentUser}
        onUpdateBacklog={onBacklogUpdate}
        onBackToBacklog={() => setActiveSession(null)}
        sessionId={activeSession.id}
      />
    );
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'Pending': return <AlertCircle className="w-4 h-4 text-orange-500" />;
      case 'Estimated': return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'Skipped': return <X className="w-4 h-4 text-gray-500" />;
      default: return <FileText className="w-4 h-4 text-blue-500" />;
    }
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'Critical': return 'bg-red-100 text-red-800 border-red-200';
      case 'High': return 'bg-orange-100 text-orange-800 border-orange-200';
      case 'Medium': return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'Low': return 'bg-green-100 text-green-800 border-green-200';
      default: return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  // Helper functions for notifications and confirmations
  const showNotification = (type: 'success' | 'error' | 'info', message: string) => {
    setNotification({ type, message, show: true });
    // Auto-hide notification after 5 seconds
    setTimeout(() => {
      setNotification(prev => ({ ...prev, show: false }));
    }, 5000);
  };

  const showConfirmDialog = (title: string, message: string, onConfirm: () => void) => {
    setConfirmDialog({
      show: true,
      title,
      message,
      onConfirm: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
        onConfirm();
      },
      onCancel: () => {
        setConfirmDialog(prev => ({ ...prev, show: false }));
      }
    });
  };

  const loadSessions = async () => {
    try {
      const activeSessions = await getActivePlanningSessions();
      setSessions(activeSessions);
      sessionsRef.current = activeSessions;
    } catch (error) {
      console.error('Error loading sessions:', error);
    }
  };

  const loadBacklogItems = async () => {
    try {
      const items = await getAllBacklogItems();
      // Convert database format to component format
      const formattedItems = items.map((item: any) => ({
        id: item.id,
        title: item.title,
        description: item.description,
        priority: item.priority,
        status: item.status,
        storyPoints: item.story_points,
        estimationType: item.estimation_type,
        acceptanceCriteria: item.acceptance_criteria || []
      }));
      onBacklogUpdate(formattedItems);
    } catch (error) {
      console.error('Error loading backlog items:', error);
    }
  };
  const loadAssignedItems = async () => {
    try {
      console.log('üìã Loading assigned items...');
      const assignedIds = await getAssignedItems();
      console.log('üìã Assigned item IDs received:', assignedIds);
      setAssignedItemIds(assignedIds);
      console.log('üìã Assigned item IDs state updated');
    } catch (error) {
      console.error('Error loading assigned items:', error);
    }
  };

  const loadSessionsWithItems = async () => {
    try {
      const sessionsData: {[key: string]: BacklogItem[]} = {};
      for (const session of sessions) {
        const items = await getSessionItems(session.id);
        const sessionBacklogItems = items
          .filter((item: any) => item.backlog_items)
          .map((item: any) => ({
            id: item.backlog_items.id,
            title: item.backlog_items.title,
            description: item.backlog_items.description,
            priority: item.backlog_items.priority,
            status: item.backlog_items.status,
            storyPoints: item.backlog_items.story_points,
            estimationType: item.backlog_items.estimation_type,
            acceptanceCriteria: item.backlog_items.acceptance_criteria || []
          }));
        sessionsData[session.id] = sessionBacklogItems;
      }
      setSessionsWithItems(sessionsData);
    } catch (error) {
      console.error('Error loading sessions with items:', error);
    }
  };

  useEffect(() => {
    if (sessions.length > 0) {
      loadSessionsWithItems();
    }
  }, [sessions, assignedItemIds]);

  const handleAddItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const dbItem = await createBacklogItem({
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const formattedItem = {
        id: dbItem.id,
        title: dbItem.title,
        description: dbItem.description,
        priority: dbItem.priority,
        status: dbItem.status,
        acceptanceCriteria: dbItem.acceptance_criteria || []
      };
      
      onBacklogUpdate([...backlogItems, formattedItem]);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
      setShowAddForm(false);
    } catch (error) {
      console.error('Error adding item:', error);
    }
  };

  const handleEditItem = (item: BacklogItem) => {
    setEditingItem(item.id);
    setNewItem({
      title: item.title,
      description: item.description,
      priority: item.priority,
      acceptanceCriteria: item.acceptanceCriteria?.join('\n') || ''
    });
  };

  const handleUpdateItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateBacklogItem(editingItem!, {
        title: newItem.title,
        description: newItem.description,
        priority: newItem.priority,
        acceptance_criteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
      });
      
      const updatedItems = backlogItems.map(item => 
        item.id === editingItem 
          ? {
              ...item,
              title: newItem.title,
              description: newItem.description,
              priority: newItem.priority,
              acceptanceCriteria: newItem.acceptanceCriteria.split('\n').filter(c => c.trim())
            }
          : item
      );
      onBacklogUpdate(updatedItems);
      setEditingItem(null);
      setNewItem({ title: '', description: '', priority: 'Medium', acceptanceCriteria: '' });
    } catch (error) {
      console.error('Error updating item:', error);
    }
  };

  const handleDeleteItem = async (id: string)